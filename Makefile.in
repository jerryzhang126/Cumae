#
# Cumae Makefile
#
# Copyright (c) 2016 Michelangelo De Simone <michel@ngelo.eu>
#
# This is meant to be included in all the individual
# Makefiles within the src/<something> directories.
#
# As this is a free project, you're free to mock around
# everything but only DEFINES, CFLAGS and LDFLAGS should
# be set in the subprojects Makefiles.
#
# TARGET __MUST__ be set and it should be a globally
# unique target name.
#
# Please see the LICENSE file for the licensing terms.
#
# TODO:
# 	Target for EEPROM flashing.
#

# Build parameters.
# These can be set and/or overridden.
DEFINES += -DF_CPU=8000000
CFLAGS += -Wall -pedantic -O
LDFLAGS += -Wl,-Map,$(TARGET).map

# Target MCU; this shouldn't be overridden in the individual
# Makefiles in src/<blah>.
MCU = atmega328p

# Flashing parameters.
FLASH_MCU = m328p
FLASH_PRG = atmelice_isp

# Directories.
#
# This obtains the absolute path of the Cumae repository by
# checking the real path of the last Makefile (which 
# should be Makefile.in).
REPOROOT := $(dir $(realpath $(lastword $(MAKEFILE_LIST))))

# Computes the final out directory.
REPOUT := $(REPOROOT)out/

# Prefix, this is also relative to the root.
PREFIX = usr/local/avr/

# Add the toolchain absolute path to the PATH.
PATH := $(REPOUT)$(PREFIX)bin/:$(PATH)

# Toolchain.
CC = avr-gcc
OC = avr-objcopy
OD = avr-objdump
AVRDUDE = avrdude

# Targets and dependencies.
#
# List all the *.c files in the current directory and
# then replace the suffix from .c to .o.
FILENAME := $(patsubst %.c, %.o, $(wildcard *.c))

# We need all the .o files for the default target; all
# the .o files are caught by the %.o target.
all: $(TARGET).elf $(TARGET).lst binaries eeprom
	rm *.o
	mv $(TARGET).elf $(REPOUT)
	mv $(TARGET).lst $(REPOUT)
	mv $(TARGET).map $(REPOUT)
	mv *.hex $(REPOUT)
	mv *.bin $(REPOUT)
	mv *.srec $(REPOUT)

# To build a .o file we need its .c file, first.
%.o: %.c
	$(CC) -mmcu=$(MCU) $(CFLAGS) $(DEFINES) $< -c -o $@

# This is the actual "main" target/dependency.
$(TARGET).elf: $(FILENAME)
	$(CC) $(CFLAGS) $(LDFLAGS) $^ -o $(TARGET).elf

# Disassembly.
%.lst: %.elf
	$(OD) -h -S $< > $@

# All the binary formats depend on the ELF target above.
binaries: $(TARGET).hex $(TARGET).bin $(TARGET).srec

%.hex: %.elf
	$(OC) -j .text -j .data -O ihex $< $@

%.srec: %.elf
	$(OC) -j .text -j .data -O srec $< $@

%.bin: %.elf
	$(OC) -j .text -j .data -O binary $< $@

# Same thing for the EEPROM targets.
eeprom: $(TARGET)_eeprom.hex $(TARGET)_eeprom.bin \
	$(TARGET)_eeprom.srec

%_eeprom.hex: %.elf
	$(OC) -j .eeprom --change-section-lma .eeprom=0 -O ihex $< $@ \
		|| { echo empty $@ not generated; exit 0; }

%_eeprom.srec: %.elf
	$(OC) -j .eeprom --change-section-lma .eeprom=0 -O srec $< $@ \
		|| { echo empty $@ not generated; exit 0; }

%_eeprom.bin: %.elf
	$(OC) -j .eeprom --change-section-lma .eeprom=0 -O binary $< $@ \
		|| { echo empty $@ not generated; exit 0; }

# Flash target. We use the ihex here.
flash: all
	$(AVRDUDE) -p $(FLASH_MCU) -c $(FLASH_PRG) \
		-U flash:w:$(REPOUT)$(TARGET).hex:i

clean:
	rm -rf $(REPOUT)$(TARGET).*
	rm -rf $(REPOUT)$(TARGET)_eeprom.*
